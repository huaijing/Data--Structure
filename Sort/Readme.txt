几种常见排序（ 代码 ）
基于比较的排序算法: 下界是 nlgn	
1.1  SelectionSort：每次选出最小的元素，放在当前循环最左边的位置。
1.2  BubbleSort：每次比较相邻的两个数，使得最大的数像气泡一样冒到最右边。
1. 3  InsertionSort：每次拿起一个数，插入到它左边数组的正确位置。
1.4  QuickSort：选择一个数，作为标准，小于它的放在左边，大于它的放在右边。并把它放在中间；递归地对左右子数组进行排序。
	实现时：1. 确定递归结束条件，初始化左右游标, 选择标准数；
		    2. while循环，do while实现两个游标同时向中间移动，置换；
	        3. 置换标准数和右边游标所指的数；
		    4. 递归调用，对左右子数组进行排序。		
1. 5  HeapSort：用最大堆实现。假设对a[]排序，实现时：
	MaxHeapify(int i)：让a[i]在最大堆中下降，使以i为根的子树成为最大堆。伪代码为：
 

	BuildMaxHeap(): 从第一个父节点到根部,自底向上依次保持最大堆性质。	
	HeapSort()：每次把最大堆的顶部元素放到当前循环的最右边。具体地，置换堆顶元素和当前的堆最后一个元素，堆大小减少，保持新的堆为最大堆。 
	      
1.6  MergeSort：拆分数组，递归实现排序，二路归并。用哨兵来阻止游标的越界。
线性时间运行的算法：
1.7  CountingSort: 假设数据分布在0到k之间的。对于每个输入x，确定出小于x的数的个数。假设小于x的数有17个，那么x就应该在第18个输出位置。
1. 8  Radix sort（基数排序）：从最低位开始，每位采用稳定的排序算法（如计数排序）。
1.9  Bucket sort：当输入数据比较均匀时采用。
	先将数据区间分为n个桶，把数据分放到对应的桶中；对桶内的数据采用插入排序；再把各个桶的排序结果串起来。